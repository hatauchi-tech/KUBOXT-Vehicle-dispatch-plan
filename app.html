<script>
/**
 * =============================================================================
 * app.js - クライアントサイドメインロジック (v3.3 - オートコンプリート機能追加)
 * =============================================================================
 */

(function() {
  'use strict';
  
  // ===========================================================================
  // ★ サーバーサイドからの変数取得 ★
  // ===========================================================================
  
  if (!window.APP_CONFIG) {
    console.error('[ERROR] APP_CONFIG が定義されていません。呼び出し元のHTMLファイルを確認してください。');
    throw new Error('APP_CONFIG が定義されていません');
  }
  const CURRENT_PAGE = window.APP_CONFIG.currentPage;
  const BASE_URL = window.APP_CONFIG.baseUrl;

  console.log('[DEBUG] APP_CONFIG loaded:', window.APP_CONFIG);
  console.log('[DEBUG] CURRENT_PAGE:', CURRENT_PAGE);
  console.log('[DEBUG] BASE_URL:', BASE_URL);
  
  // ===========================================================================
  // グローバルステート
  // ===========================================================================
  
  const AppState = {
    currentPage: CURRENT_PAGE,
    shippers: [],
    vehicles: [],
    requestTypes: [],
    addresses: [], // ★ NEW: オートコンプリート用の住所リスト
    requests: [],
    selectedRequest: null,
    loading: false,
    currentFormMode: 'create',
    currentEditingRequestId: null,
    requestDetails: [], // ★ NEW: 明細データ（一括登録用）
  };
  
  // ===========================================================================
  // API通信モジュール
  // ===========================================================================
  
  const API = {
    /**
     * GAS関数を呼び出す共通メソッド
     */
    call(functionName, ...args) {
      console.log(`[API.call] Calling: ${functionName}`, args); // ★ DEBUG LOG
      return new Promise((resolve, reject) => {
        google.script.run
          .withSuccessHandler(result => {
            console.log(`[API.call] Success: ${functionName}`, result); // ★ DEBUG LOG
            if (result && result.success === false) {
              reject(new Error(result.message || 'エラーが発生しました'));
            } else {
              resolve(result);
            }
          })
          .withFailureHandler(error => {
            console.error(`API Error [${functionName}]:`, error);
            reject(new Error('サーバーとの通信に失敗しました'));
          })
          [functionName](...args);
      });
    },
    
    async getAllShippers() {
      const result = await this.call('apiGetAllShippers');
      return result.data || [];
    },
    async getAllVehicles() {
      const result = await this.call('apiGetAllVehicles');
      return result.data || [];
    },
    async getUniqueRequestTypes() {
      const result = await this.call('apiGetUniqueRequestTypes');
      return result.data || [];
    },
    async getUniqueAddresses() { // ★ NEW: 住所リスト取得API
      const result = await this.call('apiGetUniqueAddresses');
      return result.data || [];
    },
    async getRequestById(requestId) {
      const result = await this.call('apiGetRequestById', requestId);
      return result.data || null;
    },

    /**
     * すべての依頼データを取得
     */
    async getAllRequests() {
      const result = await this.call('apiGetAllRequests');
      return result.data || [];
    },

    /**
     * ★ NEW: 指定日の配車確定済み依頼を取得
     */
    async getAssignedRequestsByDate(dateString) {
      const result = await this.call('apiGetAssignedRequestsByDate', dateString);
      return result.data || [];
    },

    /**
     * 未配車の依頼データを取得
     */
    async getUnassignedRequests() {
      const result = await this.call('apiGetUnassignedRequests');
      return result.data || [];
    },
    
    async getRequestsByDateRange(startDate, endDate) {
      const result = await this.call('apiGetRequestsByDateRange', startDate, endDate);
      return result.data || [];
    },
    async createRequest(requestData) {
      const requestJson = JSON.stringify(requestData);
      return await this.call('apiCreateRequest', requestJson);
    },
    async createRequestBatch(requestsArray) {
      const requestsJson = JSON.stringify(requestsArray);
      return await this.call('apiCreateRequestBatch', requestsJson);
    },
    async updateRequest(requestData) {
      const requestJson = JSON.stringify(requestData);
      return await this.call('apiUpdateRequest', requestJson);
    },
    async deleteRequest(requestId) {
      return await this.call('apiDeleteRequest', requestId);
    },
    async assignVehicle(requestId, vehicleNumber) {
      return await this.call('apiAssignVehicle', requestId, vehicleNumber);
    },
    async unassignVehicle(requestId) {
      return await this.call('apiUnassignVehicle', requestId);
    },
    async getAvailableVehicles(requestData) {
      const requestJson = JSON.stringify(requestData);
      const result = await this.call('apiGetAvailableVehicles', requestJson);
      return result.data || [];
    },
    async getAppInfo() {
      const result = await this.call('apiGetAppInfo');
      return result.data || {};
    }
  };
  
  // ===========================================================================
  // UI制御モジュール
  // ===========================================================================
  
  const UI = {
    showLoading(message = '読み込み中...') {
      console.log(`[UI.showLoading] ${message}`); // ★ DEBUG LOG
      AppState.loading = true;
      const loadingHtml = `
        <div class="loading-overlay" id="loadingOverlay">
          <div class="loading-spinner">
            <div class="preloader-wrapper active">
              <div class="spinner-layer spinner-blue-only">
                <div class="circle-clipper left">
                  <div class="circle"></div>
                </div>
                <div class="gap-patch">
                  <div class="circle"></div>
                </div>
                <div class="circle-clipper right">
                  <div class="circle"></div>
                </div>
              </div>
            </div>
            <p>${message}</p>
          </div>
        </div>
      `;
      this.hideLoading();
      document.body.insertAdjacentHTML('beforeend', loadingHtml);
    },
    hideLoading() {
      console.log(`[UI.hideLoading]`); // ★ DEBUG LOG
      const overlay = document.getElementById('loadingOverlay');
      if (overlay) {
        overlay.remove();
      }
      document.querySelectorAll('.loading-overlay').forEach(el => {
        el.remove();
      });
      AppState.loading = false;
    },
    showToast(message, type = 'info', duration = 3000) {
      const className = type === 'success' ? 'success' : 
                        type === 'error' ? 'error' : '';
      M.toast({ html: message, classes: className, displayLength: duration });
    },
    showError(message) {
      this.showToast(message, 'error', 5000);
    },
    showSuccess(message) {
      this.showToast(message, 'success', 3000);
    },
    confirm(message) {
      return window.confirm(message);
    }
  };
  
  // ===========================================================================
  // バリデーションモジュール
  // ===========================================================================
  
  const Validator = {
    required(value, fieldName) {
      if (!value || String(value).trim() === '') {
        return `${fieldName}は必須項目です`;
      }
      return null;
    },
    isValidDate(value, fieldName) {
      if (!value) {
        return `${fieldName}を入力してください`;
      }
      const date = new Date(value);
      if (isNaN(date.getTime())) {
        return `${fieldName}の形式が正しくありません`;
      }
      return null;
    },
    dateRange(startDate, endDate, startFieldName, endFieldName) {
      const start = new Date(startDate);
      const end = new Date(endDate);
      if (start > end) {
        return `${endFieldName}は${startFieldName}以降の日付を指定してください`;
      }
      return null;
    },
    validateForm(formData, rules) {
      const errors = [];
      for (const [field, rule] of Object.entries(rules)) {
        const value = formData[field];
        if (rule.required) {
          const error = this.required(value, rule.label);
          if (error) errors.push(error);
        }
        if (rule.type === 'date' && value) {
          const error = this.isValidDate(value, rule.label);
          if (error) errors.push(error);
        }
      }
      return errors;
    }
  };
  
  // ===========================================================================
  // ユーティリティモジュール
  // ===========================================================================
  
  const Utils = {
    formatDate(date) {
      if (!date) return '';
      const d = new Date(date);
      const year = d.getFullYear();
      const month = String(d.getMonth() + 1).padStart(2, '0');
      const day = String(d.getDate()).padStart(2, '0');
      return `${year}-${month}-${day}`;
    },
    formatTime(time) {
      if (!time) return '';
      // 'HH:mm' 形式の文字列が来ることがあるため、Dateコンストラクタを避ける
      if (typeof time === 'string' && time.match(/^\d{2}:\d{2}$/)) {
        return time;
      }
      // DateオブジェクトまたはISO文字列の場合
      try {
        const d = new Date(time);
        if (isNaN(d.getTime())) return ''; // 無効な日付
        const hours = String(d.getHours()).padStart(2, '0');
        const minutes = String(d.getMinutes()).padStart(2, '0');
        return `${hours}:${minutes}`;
      } catch (e) {
        return '';
      }
    },
    formatDateJP(date) {
      if (!date) return '';
      const d = new Date(date);
      const year = d.getFullYear();
      const month = d.getMonth() + 1;
      const day = d.getDate();
      return `${year}年${month}月${day}日`;
    },
    getToday() {
      return this.formatDate(new Date());
    },
    filterArray(array, filterFn) {
      if (!Array.isArray(array)) return [];
      return array.filter(filterFn);
    },
    sortArray(array, key, ascending = true) {
      if (!Array.isArray(array)) return [];
      return [...array].sort((a, b) => {
        const aVal = a[key];
        const bVal = b[key];
        // 時間の比較 (例: "09:00")
        if (typeof aVal === 'string' && aVal.match(/^\d{2}:\d{2}$/)) {
          return ascending ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);
        }
        // 日付や数値の比較
        if (aVal < bVal) return ascending ? -1 : 1;
        if (aVal > bVal) return ascending ? 1 : -1;
        return 0;
      });
    },
    cloneObject(obj) {
      return JSON.parse(JSON.stringify(obj));
    },
    toggleElement(elementId, show) {
      const element = document.getElementById(elementId);
      if (element) {
        element.style.display = show ? 'block' : 'none';
      }
    },
    populateSelect(selectId, options, valueKey, textKey, placeholder = '選択してください') {
      const select = document.getElementById(selectId);
      if (!select) return;
      const currentValue = select.value; // 編集モードでの値保持
      select.innerHTML = `<option value="" disabled>${placeholder}</option>`; // selectedを削除
      options.forEach(option => {
        const optionElement = document.createElement('option');
        optionElement.value = option[valueKey];
        optionElement.textContent = option[textKey];
        select.appendChild(optionElement);
      });
      // 適切な値を選択状態にする
      select.value = currentValue || "";
      M.FormSelect.init(select);
    },
    clearForm(formId) {
      const form = document.getElementById(formId);
      if (form) {
        form.reset();
        const hiddenId = document.getElementById('requestId');
        if (hiddenId) hiddenId.value = '';
        const selects = form.querySelectorAll('select');
        selects.forEach(select => {
          select.value = ""; // 値をリセット
          M.FormSelect.init(select);
        });
        const labels = form.querySelectorAll('label');
        labels.forEach(label => {
          label.classList.remove('active');
        });
        const datePickers = form.querySelectorAll('.datepicker, .timepicker');
        datePickers.forEach(picker => {
          const label = picker.nextElementSibling;
          if(label) label.classList.add('active');
        });
      }
    }
  };
  
  // ===========================================================================
  // ナビゲーションモジュール
  // ===========================================================================
  
  const Navigation = {
    _navigating: false,
    _currentState: {}, 
    navigateToPage(pageName, state = {}, meta = { source: 'unknown' }) {
      console.log('[SPA] navigateToPage called with:', pageName, 'state:', state, 'source:', meta.source);
      if (this._navigating) {
        console.log('[WARN] Navigation already in progress, ignoring');
        return;
      }
      if (pageName === AppState.currentPage && JSON.stringify(state) === JSON.stringify(this._currentState)) {
        console.log('[SPA] Already on page with same state:', pageName);
        return;
      }
      this._navigating = true;
      UI.showLoading('ページを読み込んでいます...');
      this._currentState = state; 
      google.script.run
        .withSuccessHandler((html) => {
          console.log('[SPA] Page content loaded successfully for:', pageName);
          const contentDiv = document.getElementById('page-content');
          if (contentDiv) {
            contentDiv.innerHTML = html;
          } else {
            console.error('[ERROR] page-content div not found!');
            UI.showError('ページコンテンツの配置に失敗しました');
            UI.hideLoading();
            this._navigating = false;
            return;
          }
          AppState.currentPage = pageName;
          this.updateActiveNavLinks(pageName);
          App.initPage(this._currentState).then(() => {
            UI.hideLoading();
            this._navigating = false;
            console.log('[SPA] Navigation completed successfully to:', pageName);
          }).catch((error) => {
            console.error('[ERROR] Page initialization failed:', error);
            UI.hideLoading();
            UI.showError('ページの初期化に失敗しました: ' + error.message);
            this._navigating = false;
          });
        })
        .withFailureHandler((error) => {
          console.error('[ERROR] Failed to load page content:', error);
          UI.hideLoading();
          UI.showError('ページの読み込みに失敗しました: ' + error.message);
          this._navigating = false;
        })
        .getPageContent(pageName);
    },
    updateActiveNavLinks(activePage) {
      console.log('[SPA] Updating active nav links for:', activePage);
      document.querySelectorAll('nav li').forEach(li => {
        li.classList.remove('active');
      });
      document.querySelectorAll(`nav a[data-page="${activePage}"]`).forEach(link => {
        const li = link.closest('li');
        if (li) {
          li.classList.add('active');
        }
      });
    },
    setupEventListeners() {
      console.log('[SPA] Setting up navigation event listeners');
      const onClickNav = (e) => {
        if (!e.isTrusted) {
          return;
        }
        e.preventDefault();
        const link = e.currentTarget;
        const pageName = link.getAttribute('data-page') || 'dispatch-plan';
        this.navigateToPage(pageName, {}, { source: 'user-click' });
      };
      const brandLogo = document.getElementById('brandLogo');
      if (brandLogo) {
        brandLogo.addEventListener('click', onClickNav, { capture: true });
      }
      const navLinks = document.querySelectorAll('a[data-page]');
      navLinks.forEach((link, index) => {
        link.addEventListener('click', onClickNav, { capture: true });
      });
    }
  };
  
  // ===========================================================================
  // メインアプリケーションモジュール
  // ===========================================================================
  
  const App = {
    async init() {
      console.log('[App.init] App initializing...'); // ★ DEBUG LOG
      try {
        UI.showLoading('アプリケーションを初期化中...');
        this.setupEventListeners();
        this.initMaterialize();
        await this.loadMasterData();
        await this.initPage(Navigation._currentState);
        UI.hideLoading();
        console.log('[App.init] App initialized successfully'); // ★ DEBUG LOG
      } catch (error) {
        console.error('[App.init] App initialization error:', error); // ★ DEBUG LOG
        UI.hideLoading();
        UI.showError('アプリケーションの初期化に失敗しました: ' + error.message);
      }
    },
    initMaterialize() {
      console.log('[App.initMaterialize] Initializing Materialize components manually'); // ★ DEBUG LOG
      const sidenavElems = document.querySelectorAll('.sidenav');
      if (sidenavElems.length > 0) M.Sidenav.init(sidenavElems);
      const selectElems = document.querySelectorAll('select');
      if (selectElems.length > 0) M.FormSelect.init(selectElems);
      const datepickerElems = document.querySelectorAll('.datepicker');
      if (datepickerElems.length > 0) {
        M.Datepicker.init(datepickerElems, {
          format: 'yyyy-mm-dd', autoClose: true,
          i18n: {
            cancel: 'キャンセル', done: '選択',
            months: ['1月', '2月', '3月', '4月', '5月', '6月', '7月', '8月', '9月', '10月', '11月', '12月'],
            monthsShort: ['1月', '2月', '3月', '4月', '5月', '6月', '7月', '8月', '9月', '10月', '11月', '12月'],
            weekdays: ['日曜日', '月曜日', '火曜日', '水曜日', '木曜日', '金曜日', '土曜日'],
            weekdaysShort: ['日', '月', '火', '水', '木', '金', '土'],
            weekdaysAbbrev: ['日', '月', '火', '水', '木', '金', '土']
          }
        });
      }
      const timepickerElems = document.querySelectorAll('.timepicker');
      if (timepickerElems.length > 0) {
        M.Timepicker.init(timepickerElems, {
          twelveHour: false,
          i18n: { cancel: 'キャンセル', done: '選択' }
        });
      }
      const modalElems = document.querySelectorAll('.modal');
      if (modalElems.length > 0) M.Modal.init(modalElems);
      const tabsElems = document.querySelectorAll('.tabs');
      if (tabsElems.length > 0) M.Tabs.init(tabsElems);

      // ★ NEW: オートコンプリートの初期化
      this.initAutocomplete();

      M.updateTextFields();
    },
    
    /**
     * ★ NEW: 住所オートコンプリートの初期化
     */
    initAutocomplete() {
      const addressInputs = document.querySelectorAll(
        '#loadPlace1, #loadPlace2, #unloadPlace1, #unloadPlace2'
      );
      
      if (addressInputs.length === 0 || AppState.addresses.length === 0) {
        return;
      }
      
      console.log(`[App.initAutocomplete] Initializing ${addressInputs.length} inputs with ${AppState.addresses.length} addresses`); // ★ DEBUG LOG

      // MaterializeのAutocompleteはデータを { "key": "value" } 形式で要求する
      const autocompleteData = AppState.addresses.reduce((acc, address) => {
        acc[address] = null; // null（画像なし）
        return acc;
      }, {});

      const options = {
        data: autocompleteData,
        limit: 5, // 候補の最大表示数
        minLength: 1, // 1文字からサジェスト開始
        onAutocomplete: function(val) {
          // 選択時にテキストフィールドを更新（M.updateTextFieldsは不要）
          const instance = M.Autocomplete.getInstance(this.el);
          instance.el.value = val;
        }
      };

      addressInputs.forEach(input => {
        M.Autocomplete.init(input, options);
      });
    },

    async loadMasterData() {
      console.log('[App.loadMasterData] Loading master data...'); // ★ DEBUG LOG
      try {
        const [shippers, vehicles, requestTypes, addresses] = await Promise.all([ // ★ MOD: addresses を追加
          API.getAllShippers(),
          API.getAllVehicles(),
          API.getUniqueRequestTypes(),
          API.getUniqueAddresses() // ★ NEW: 住所リストを取得
        ]);
        AppState.shippers = shippers;
        AppState.vehicles = vehicles;
        AppState.requestTypes = requestTypes;
        AppState.addresses = addresses; // ★ NEW: AppState に保存
        console.log('[App.loadMasterData] Master data loaded successfully'); // ★ DEBUG LOG
      } catch (error) {
        console.error('[App.loadMasterData] Failed to load master data:', error); // ★ DEBUG LOG
        throw new Error('マスタデータの読み込みに失敗しました');
      }
    },
    async initPage(state = {}) {
      const page = AppState.currentPage;
      console.log(`[App.initPage] Initializing page: ${page} with state:`, state); // ★ DEBUG LOG
      switch (page) {
        case 'request-form':
          await RequestForm.init(state);
          break;
        case 'request-list':
          await RequestList.init();
          break;
        case 'dispatch-plan':
          await DispatchPlan.init();
          break;
        default:
          console.warn(`[App.initPage] Unknown page or no page-specific init required: ${page}`); // ★ DEBUG LOG
      }
    },
    setupEventListeners() {
      Navigation.setupEventListeners();
    }
  };
  
  // ===========================================================================
  // ページ別モジュール
  // ===========================================================================
  
  // 依頼入力画面モジュール
  const RequestForm = {
    async init(state = {}) {
      console.log('[RequestForm.init] with state:', state); // ★ DEBUG LOG
      if (state.mode === 'edit' && state.requestId) {
        AppState.currentFormMode = 'edit';
        AppState.currentEditingRequestId = state.requestId;
      } else {
        AppState.currentFormMode = 'create';
        AppState.currentEditingRequestId = null;
        AppState.requestDetails = []; // ★ NEW: 新規登録モード時は明細をクリア
      }
      this.setupEventListeners();
      this.setupFormUI();
      await this.populateFormData();
      this.renderDetailTable(); // ★ NEW: 明細テーブルを初期化
      App.initAutocomplete(); // ★ NEW: ページ遷移時にもAutocompleteを再初期化
    },
    setupFormUI() {
      console.log(`[RequestForm.setupFormUI] Mode: ${AppState.currentFormMode}`); // ★ DEBUG LOG
      const title = document.getElementById('pageTitle');
      const subtitle = document.getElementById('pageSubtitle');
      const submitBtnText = document.getElementById('submitBtnText');
      const cancelBtnText = document.getElementById('cancelBtnText');
      if (AppState.currentFormMode === 'edit') {
        if (title) title.innerHTML = '<i class="material-icons large" style="vertical-align: middle;">edit</i> 依頼編集';
        if (subtitle) subtitle.textContent = `依頼ID: ${AppState.currentEditingRequestId} の内容を編集します`;
        if (submitBtnText) submitBtnText.textContent = '更新';
        if (cancelBtnText) cancelBtnText.textContent = 'キャンセル';
      } else {
        if (title) title.innerHTML = '<i class="material-icons large" style="vertical-align: middle;">add_circle</i> 依頼登録';
        if (subtitle) subtitle.textContent = '新規配送依頼を登録します';
        if (submitBtnText) submitBtnText.textContent = '登録';
        if (cancelBtnText) cancelBtnText.textContent = 'クリア';
      }
    },
    async populateFormData() {
      console.log('[RequestForm.populateFormData] Populating selects...'); // ★ DEBUG LOG
      Utils.populateSelect('shipper', AppState.shippers, 'shipperId', 'shipperName', '荷主を選択');

      // ★ NEW: 明細入力用の依頼車種セレクトも初期化
      Utils.populateSelect('detailRequestType', AppState.requestTypes.map(type => ({
        value: type,
        label: type
      })), 'value', 'label', '依頼車種を選択');

      if (AppState.currentFormMode === 'edit') {
        console.log(`[RequestForm.populateFormData] Edit mode: Loading data for ${AppState.currentEditingRequestId}`); // ★ DEBUG LOG
        try {
          UI.showLoading('依頼データを読み込み中...');
          const data = await API.getRequestById(AppState.currentEditingRequestId);
          if (data) {
            console.log('[RequestForm.populateFormData] Data loaded:', data); // ★ DEBUG LOG
            document.getElementById('requestId').value = data.requestId;
            document.getElementById('receivedDate').value = Utils.formatDate(data.receivedDate);
            document.getElementById('shipper').value = data.shipperId;
            document.getElementById('productName').value = data.productName;
            document.getElementById('requestType').value = data.requestType;
            document.getElementById('loadDate').value = Utils.formatDate(data.loadDate);
            document.getElementById('loadTime').value = Utils.formatTime(data.loadTime);
            document.getElementById('loadPlace1').value = data.loadPlace1;
            document.getElementById('loadPlace2').value = data.loadPlace2;
            document.getElementById('unloadDate').value = Utils.formatDate(data.unloadDate);
            document.getElementById('unloadTime').value = Utils.formatTime(data.unloadTime);
            document.getElementById('unloadPlace1').value = data.unloadPlace1;
            document.getElementById('unloadPlace2').value = data.unloadPlace2;
            
            M.FormSelect.init(document.querySelectorAll('select'));
            M.updateTextFields();
          } else {
            UI.showError('依頼データの読み込みに失敗しました');
          }
          UI.hideLoading();
        } catch (error) {
          console.error('Load request data error:', error);
          UI.hideLoading();
          UI.showError('依頼データの読み込みに失敗しました: ' + error.message);
        }
      } else {
        console.log('[RequestForm.populateFormData] Create mode: Setting default date'); // ★ DEBUG LOG
        const receivedDateInput = document.getElementById('receivedDate');
        if (receivedDateInput) {
          receivedDateInput.value = Utils.getToday();
        }
        M.updateTextFields();
      }
    },
    setupEventListeners() {
      console.log('[RequestForm.setupEventListeners]'); // ★ DEBUG LOG
      const form = document.getElementById('requestForm');
      if (form) {
        form.removeEventListener('submit', this.handleSubmit);
        form.addEventListener('submit', (e) => this.handleSubmit(e));
      }
      const cancelBtn = document.getElementById('cancelBtn');
      if (cancelBtn) {
        cancelBtn.removeEventListener('click', this.handleCancel);
        cancelBtn.addEventListener('click', () => this.handleCancel());
      }

      // ★ NEW: 明細追加ボタンのイベントリスナー
      const addDetailBtn = document.getElementById('addDetailBtn');
      if (addDetailBtn) {
        addDetailBtn.removeEventListener('click', this.addDetail);
        addDetailBtn.addEventListener('click', () => this.addDetail());
      }
    },
    async handleSubmit(e) {
      e.preventDefault();
      console.log('[RequestForm.handleSubmit] Form submitted'); // ★ DEBUG LOG
      const formData = this.getFormData();
      const errors = this.validateFormData(formData);
      if (errors.length > 0) {
        UI.showError(errors.join('\n'));
        return;
      }
      try {
        if (AppState.currentFormMode === 'edit') {
          // 編集モードでは従来通り単一更新（明細機能は使用しない）
          console.log('[RequestForm.handleSubmit] Updating request...'); // ★ DEBUG LOG
          UI.showLoading('依頼を更新中...');
          const result = await API.updateRequest(formData);
          UI.hideLoading();
          if (result.success) {
            UI.showSuccess('依頼を更新しました (ID: ' + formData.requestId + ')');
            Navigation.navigateToPage('request-list', {}, { source: 'form-submit' });
          } else {
            UI.showError('依頼の更新に失敗しました: ' + result.message);
          }
        } else {
          // ★ NEW: 新規登録時は一括登録APIを使用
          console.log('[RequestForm.handleSubmit] Creating batch requests...', AppState.requestDetails.length); // ★ DEBUG LOG
          UI.showLoading(`${AppState.requestDetails.length}件の依頼を登録中...`);

          // 基本情報 + 各明細の組み合わせで依頼データ配列を作成
          const requestsArray = AppState.requestDetails.map(detail => ({
            ...formData,
            productName: detail.productName,
            requestType: detail.requestType
          }));

          const result = await API.createRequestBatch(requestsArray);
          UI.hideLoading();

          if (result.success) {
            const requestIds = result.requestIds || [];
            UI.showSuccess(`${requestIds.length}件の依頼を登録しました\n最初のID: ${requestIds[0]}\n最後のID: ${requestIds[requestIds.length - 1]}`);
            Utils.clearForm('requestForm');
            AppState.requestDetails = []; // 明細をクリア
            this.renderDetailTable(); // テーブルを再描画
            this.setupFormUI();
            this.populateFormData();
          } else {
            UI.showError('依頼の登録に失敗しました: ' + result.message);
          }
        }
      } catch (error) {
        console.error('Submit error:', error);
        UI.hideLoading();
        UI.showError('処理に失敗しました: ' + error.message);
      }
    },
    getFormData() {
      const data = {
        requestId: document.getElementById('requestId').value,
        receivedDate: document.getElementById('receivedDate').value,
        shipper: document.getElementById('shipper').value,
        loadDate: document.getElementById('loadDate').value,
        loadTime: document.getElementById('loadTime').value,
        loadPlace1: document.getElementById('loadPlace1').value,
        loadPlace2: document.getElementById('loadPlace2').value,
        unloadDate: document.getElementById('unloadDate').value,
        unloadTime: document.getElementById('unloadTime').value,
        unloadPlace1: document.getElementById('unloadPlace1').value,
        unloadPlace2: document.getElementById('unloadPlace2').value
        // ★ NOTE: productName と requestType は明細入力に移動したため削除
      };
      console.log('[RequestForm.getFormData]', data); // ★ DEBUG LOG
      return data;
    },
    validateFormData(formData) {
      const errors = [];
      if (!formData.shipper) errors.push('荷主を選択してください');
      if (!formData.loadDate) errors.push('積込日を入力してください');
      if (!formData.loadPlace1) errors.push('積込地1を入力してください');
      if (!formData.unloadDate) errors.push('荷卸日を入力してください');
      if (!formData.unloadPlace1) errors.push('荷卸地1を入力してください');
      // ★ NOTE: productName と requestType は明細入力時にバリデーション
      if (formData.loadDate && formData.unloadDate) {
        const error = Validator.dateRange(
          formData.loadDate,
          formData.unloadDate,
          '積込日',
          '荷卸日'
        );
        if (error) errors.push(error);
      }

      // ★ NEW: 明細が1件以上登録されているかチェック
      if (AppState.requestDetails.length === 0) {
        errors.push('明細を1件以上登録してください');
      }

      return errors;
    },
    handleCancel() {
      if (AppState.currentFormMode === 'edit') {
        if (UI.confirm('編集をキャンセルして一覧に戻りますか?')) {
          Navigation.navigateToPage('request-list', {}, { source: 'form-cancel' });
        }
      } else {
        if (UI.confirm('入力内容をクリアしますか?')) {
          Utils.clearForm('requestForm');
          AppState.requestDetails = []; // ★ NEW: 明細もクリア
          this.renderDetailTable(); // ★ NEW: テーブルを再描画
          this.populateFormData();
        }
      }
    },

    // ★★★ NEW: 明細管理関数 ★★★
    addDetail() {
      const requestType = document.getElementById('detailRequestType').value;
      const productName = document.getElementById('detailProductName').value.trim();

      // バリデーション
      if (!requestType) {
        UI.showError('依頼車種を選択してください');
        return;
      }
      if (!productName) {
        UI.showError('品名を入力してください');
        return;
      }

      // 明細を追加
      AppState.requestDetails.push({
        requestType: requestType,
        productName: productName
      });

      // 入力フィールドをクリア
      document.getElementById('detailRequestType').value = '';
      document.getElementById('detailProductName').value = '';
      M.FormSelect.init(document.querySelectorAll('select'));
      M.updateTextFields();

      // テーブルを再描画
      this.renderDetailTable();

      console.log('[RequestForm.addDetail] Detail added:', AppState.requestDetails);
    },

    removeDetail(index) {
      if (UI.confirm('この明細を削除しますか?')) {
        AppState.requestDetails.splice(index, 1);
        this.renderDetailTable();
        console.log('[RequestForm.removeDetail] Detail removed. Remaining:', AppState.requestDetails);
      }
    },

    renderDetailTable() {
      const tableBody = document.getElementById('detailTableBody');
      const table = document.getElementById('detailTable');
      const noDetailMessage = document.getElementById('noDetailMessage');
      const detailCount = document.getElementById('detailCount');

      if (!tableBody || !table || !noDetailMessage || !detailCount) return;

      // 件数を更新
      detailCount.textContent = AppState.requestDetails.length;

      if (AppState.requestDetails.length === 0) {
        // 明細がない場合
        table.style.display = 'none';
        noDetailMessage.style.display = 'block';
        tableBody.innerHTML = '';
      } else {
        // 明細がある場合
        table.style.display = 'table';
        noDetailMessage.style.display = 'none';

        // テーブル行を生成
        tableBody.innerHTML = AppState.requestDetails.map((detail, index) => `
          <tr>
            <td>${index + 1}</td>
            <td>${detail.requestType}</td>
            <td>${detail.productName}</td>
            <td class="center-align">
              <button type="button" class="btn-small red waves-effect waves-light" onclick="RequestForm.removeDetail(${index})">
                <i class="material-icons">delete</i>
              </button>
            </td>
          </tr>
        `).join('');
      }
    }
  };
  
  // 依頼一覧モジュール
  const RequestList = {
    async init() {
      console.log('[RequestList.init]'); // ★ DEBUG LOG
      this.setupEventListeners();
      this.populateFilters();
      await this.loadRequests();
    },
    populateFilters() {
      Utils.populateSelect('filterShipper', AppState.shippers, 'shipperId', 'shipperName', 'すべての荷主');
    },
    async loadRequests() {
      console.log('[RequestList.loadRequests] Loading all requests...'); // ★ DEBUG LOG
      try {
        UI.showLoading('依頼データを読み込み中...');
        const requests = await API.getAllRequests();
        AppState.requests = requests;
        this.renderTable(requests);
        this.updateRequestCount(requests.length);
        UI.hideLoading();
      } catch (error) {
        console.error('Load requests error:', error);
        UI.hideLoading();
        UI.showError('依頼データの読み込みに失敗しました');
      }
    },
    renderTable(requests) {
      console.log(`[RequestList.renderTable] Rendering ${requests.length} requests`); // ★ DEBUG LOG
      const tbody = document.getElementById('requestTableBody');
      if (!tbody) return;
      if (requests.length === 0) {
        tbody.innerHTML = '<tr><td colspan="10" class="text-center">データがありません</td></tr>';
        return;
      }
      const sortedRequests = Utils.sortArray(requests, 'loadDate', false);
      tbody.innerHTML = sortedRequests.map(req => `
        <tr>
          <td class="table-actions" style="min-width: 120px;">
            <button class="btn-small waves-effect waves-light blue edit-btn" data-request-id="${req.requestId}" title="編集">
              <i class="material-icons">edit</i>
            </button>
            <button class="btn-small waves-effect waves-light red delete-btn" data-request-id="${req.requestId}" title="削除">
              <i class="material-icons">delete</i>
            </button>
          </td>
          <td>
            ${req.vehicleNumber 
              ? '<span class="chip chip-assigned">配車済</span>' 
              : '<span class="chip chip-unassigned">未配車</span>'}
          </td>
          <td>${req.requestId}</td>
          <td>${Utils.formatDateJP(req.loadDate)}</td>
          <td>${req.shipper}</td>
          <td>${req.loadPlace1}</td>
          <td>${req.productName}</td>
          <td>${req.requestType}</td>
          <td>${req.vehicleNumber || '-'}</td>
          <td>${req.driverName || '-'}</td>
        </tr>
      `).join('');
    },
    setupEventListeners() {
      const applyBtn = document.getElementById('applyFilterBtn');
      if (applyBtn) {
        applyBtn.addEventListener('click', () => this.applyFilters());
      }
      const resetBtn = document.getElementById('resetFilterBtn');
      if (resetBtn) {
        resetBtn.addEventListener('click', () => this.resetFilters());
      }
      const tableBody = document.getElementById('requestTableBody');
      if (tableBody) {
        tableBody.addEventListener('click', (e) => {
          const editBtn = e.target.closest('.edit-btn');
          const deleteBtn = e.target.closest('.delete-btn');
          if (editBtn) {
            const requestId = editBtn.dataset.requestId;
            this.handleEditClick(requestId);
          } else if (deleteBtn) {
            const requestId = deleteBtn.dataset.requestId;
            this.handleDeleteClick(requestId);
          }
        });
      }
    },
    applyFilters() {
      if (!AppState.requests) return;
      const startDate = document.getElementById('filterStartDate').value;
      const endDate = document.getElementById('filterEndDate').value;
      const shipperId = document.getElementById('filterShipper').value;
      const status = document.getElementById('filterStatus').value;
      
      let filtered = AppState.requests;
      
      if (startDate) {
        filtered = filtered.filter(req => req.loadDate >= startDate);
      }
      if (endDate) {
        filtered = filtered.filter(req => req.loadDate <= endDate);
      }
      if (shipperId) {
        filtered = filtered.filter(req => req.shipperId === shipperId);
      }
      if (status === 'assigned') {
        filtered = filtered.filter(req => req.vehicleNumber);
      } else if (status === 'unassigned') {
        filtered = filtered.filter(req => !req.vehicleNumber);
      }
      
      this.renderTable(filtered);
      this.updateRequestCount(filtered.length);
    },
    resetFilters() {
      document.getElementById('filterStartDate').value = '';
      document.getElementById('filterEndDate').value = '';
      document.getElementById('filterShipper').value = '';
      document.getElementById('filterStatus').value = '';
      M.FormSelect.init(document.querySelectorAll('select'));
      this.renderTable(AppState.requests);
      this.updateRequestCount(AppState.requests.length);
    },
    updateRequestCount(count) {
      const countElem = document.getElementById('requestCount');
      if (countElem) {
        countElem.textContent = `全 ${count} 件`;
      }
    },
    handleEditClick(requestId) {
      console.log('[RequestList.handleEditClick] ID:', requestId); // ★ DEBUG LOG
      Navigation.navigateToPage('request-form', { 
        mode: 'edit', 
        requestId: requestId 
      }, { source: 'list-edit-btn' });
    },
    async handleDeleteClick(requestId) {
      console.log('[RequestList.handleDeleteClick] ID:', requestId); // ★ DEBUG LOG
      if (!UI.confirm(`依頼ID: ${requestId} を削除しますか？\nこの操作は元に戻せません。`)) {
        return;
      }
      try {
        UI.showLoading('依頼を削除中...');
        const result = await API.deleteRequest(requestId);
        UI.hideLoading();
        if (result.success) {
          UI.showSuccess('依頼を削除しました');
          await this.loadRequests();
        } else {
          UI.showError('依頼の削除に失敗しました: ' + result.message);
        }
      } catch (error) {
        console.error('Delete request error:', error);
        UI.hideLoading();
        UI.showError('依頼の削除に失敗しました: ' + error.message);
      }
    }
  };
  
  // 配車計画モジュール
  const DispatchPlan = {
    async init() {
      console.log('[DispatchPlan.init] Initializing...'); // ★ DEBUG LOG
      this.setupEventListeners();
      this.populateFilters();

      UI.showLoading('依頼データを読み込み中...');
      try {
        console.log('[DispatchPlan.init] Awaiting this.loadUnassignedRequests...'); // ★ DEBUG LOG
        await this.loadUnassignedRequests(); // ★ MOD: 分離

        console.log('[DispatchPlan.init] Awaiting this.loadAssignedRequestsByDate...'); // ★ DEBUG LOG
        await this.loadAssignedRequestsByDate(0); // ★ MOD: デフォルトで本日を表示

      } catch (error) {
        console.error('[DispatchPlan.init] Load requests error:', error); // ★ DEBUG LOG
        UI.showError('依頼データの読み込みに失敗しました');
      } finally {
        UI.hideLoading();
      }
    },

    /**
     * ★ NEW: 指定された日付の配車確定データを読み込む
     * @param {number} dateOffset - 日付のオフセット (0=本日, -1=昨日, -2=一昨日)
     */
    async loadAssignedRequestsByDate(dateOffset = 0) {
      // 日付を計算
      const targetDate = new Date();
      targetDate.setDate(targetDate.getDate() + dateOffset);
      const targetDateString = Utils.formatDate(targetDate);

      console.log(`[DispatchPlan.loadAssignedRequestsByDate] Loading for offset: ${dateOffset}, date: ${targetDateString}`); // ★ DEBUG LOG

      // 日付ラベルと表示を更新
      const dateLabelMap = {
        0: '本日',
        '-1': '昨日',
        '-2': '一昨日'
      };
      const dateLabel = dateLabelMap[dateOffset] || `${dateOffset}日前`;

      const selectedDateLabelElem = document.getElementById('selectedDateLabel');
      if (selectedDateLabelElem) {
        selectedDateLabelElem.textContent = dateLabel;
      }

      const todayDateElem = document.getElementById('todayDateStr');
      if (todayDateElem) {
        todayDateElem.textContent = Utils.formatDateJP(targetDateString);
      }

      // ボタンのアクティブ状態を更新
      this.updateDateButtonStates(dateOffset);

      try {
        const requests = await API.getAssignedRequestsByDate(targetDateString);
        console.log(`[DispatchPlan.loadAssignedRequestsByDate] Received ${requests.length} assigned requests`); // ★ DEBUG LOG
        this.renderTodayAssignedRequests(requests);
      } catch (error) {
        console.error('[DispatchPlan.loadAssignedRequestsByDate] Load assigned requests error:', error); // ★ DEBUG LOG
        UI.showError('配車計画の読み込みに失敗しました');
        const container = document.getElementById('todayAssignedRequests');
        if (container) {
          container.innerHTML = '<p class="text-center text-error">データの読み込みに失敗しました</p>';
        }
      }
    },

    /**
     * ★ NEW: 日付選択ボタンのアクティブ状態を更新
     * @param {number} activeOffset - アクティブにするボタンのオフセット
     */
    updateDateButtonStates(activeOffset) {
      const buttons = [
        { id: 'showDayBeforeYesterdayBtn', offset: -2 },
        { id: 'showYesterdayBtn', offset: -1 },
        { id: 'showTodayBtn', offset: 0 }
      ];

      buttons.forEach(btn => {
        const element = document.getElementById(btn.id);
        if (element) {
          if (btn.offset === activeOffset) {
            element.classList.remove('grey', 'lighten-1');
            element.classList.add('blue', 'darken-1');
          } else {
            element.classList.remove('blue', 'darken-1');
            element.classList.add('grey', 'lighten-1');
          }
        }
      });
    },
    
    /**
     * 当日の配車確定データを描画する
     */
    renderTodayAssignedRequests(requests) {
      console.log(`[DispatchPlan.renderToday] Rendering ${requests.length} requests.`); // ★ DEBUG LOG
      const container = document.getElementById('todayAssignedRequests');
      if (!container) {
         console.error('[DispatchPlan.renderToday] Container #todayAssignedRequests not found!'); // ★ DEBUG LOG
         return;
      }
      
      if (requests.length === 0) {
        container.innerHTML = '<p class="text-center text-secondary">本日の配車確定済み依頼はありません</p>';
        return;
      }
      
      // 車両ごとにグループ化
      const groupedByVehicle = requests.reduce((acc, req) => {
        const key = req.vehicleNumber || 'unknown';
        if (!acc[key]) {
          acc[key] = {
            driverName: req.driverName,
            vehicleType: req.vehicleType,
            requests: []
          };
        }
        acc[key].requests.push(req);
        return acc;
      }, {});
      
      // 時間でソート
      for (const vehicle in groupedByVehicle) {
        groupedByVehicle[vehicle].requests = Utils.sortArray(groupedByVehicle[vehicle].requests, 'loadTime', true);
      }
      
      // HTMLを構築
      container.innerHTML = Object.entries(groupedByVehicle).map(([vehicleNumber, data]) => {
        return `
          <div class="card vehicle-plan-card">
            <div class="card-content">
              <div class="card-title" style="font-size: 1.25rem; color: #1976D2; margin-bottom: 10px;">
                <i class="material-icons left">local_shipping</i>
                ${vehicleNumber} (${data.driverName || '未設定'})
                <span class="chip chip-info right">${data.vehicleType}</span>
              </div>
              
              ${data.requests.map(req => `
                <div class="request-plan-item">
                  <div class="request-plan-time">${Utils.formatTime(req.loadTime) || '時間未定'}</div>
                  <div class="request-plan-details">
                    <strong>${req.shipper}</strong> - ${req.productName}
                    <div class="request-info">
                      積: ${req.loadPlace1}
                      <span class="right">卸: ${req.unloadPlace1}</span>
                    </div>
                  </div>
                  <div class="request-plan-action">
                    <button class="btn-small waves-effect waves-light amber darken-3 unassign-btn" 
                            data-request-id="${req.requestId}" 
                            title="配車を解除する">
                      <i class="material-icons">undo</i>
                    </button>
                  </div>
                </div>
              `).join('')}
              
            </div>
          </div>
        `;
      }).join('');
    },

    populateFilters() {
      Utils.populateSelect('planFilterShipper', AppState.shippers, 'shipperId', 'shipperName', 'すべての荷主');
      Utils.populateSelect('planFilterType', AppState.requestTypes.map(type => ({
        value: type,
        label: type
      })), 'value', 'label', 'すべての車種');
    },
    
    /**
     * 未配車タブのデータ読み込み
     */
    async loadUnassignedRequests() {
      console.log('[DispatchPlan.loadUnassigned] Loading all requests for unassigned tab...'); // ★ DEBUG LOG
      try {
        const requests = await API.getAllRequests();
        AppState.requests = requests;
        this.applyPlanFilters(); // フィルター適用して描画
        console.log('[DispatchPlan.loadUnassigned] Unassigned requests loaded and rendered.'); // ★ DEBUG LOG
      } catch (error) {
        console.error('[DispatchPlan.loadUnassigned] Load unassigned requests error:', error); // ★ DEBUG LOG
        UI.showError('未配車依頼の読み込みに失敗しました');
      }
    },
    
    renderRequests(requests) {
      console.log(`[DispatchPlan.renderRequests] Rendering ${requests.length} unassigned requests`); // ★ DEBUG LOG
      const container = document.getElementById('unassignedRequests');
      if (!container) return;
      const countElem = document.getElementById('unassignedCount');
      if (countElem) {
        countElem.textContent = `(${requests.length} 件)`;
      }
      if (requests.length === 0) {
        container.innerHTML = '<p class="text-center text-secondary">対象の依頼はありません</p>';
        return;
      }
      const sortedRequests = Utils.sortArray(requests, 'loadDate', true);
      container.innerHTML = sortedRequests.map(req => `
        <div class="request-card" data-request-id="${req.requestId}">
          <div class="request-card-header">
            <span class="request-id">${req.requestId}</span>
            <span class="chip chip-info">${req.requestType}</span>
          </div>
          <div class="request-info">
            <strong>${req.shipper}</strong> - ${req.productName}
          </div>
          <div class="request-info">
            積込: ${Utils.formatDateJP(req.loadDate)} ${Utils.formatTime(req.loadTime) || ''} - ${req.loadPlace1}
          </div>
          <div class="request-info">
            荷卸: ${Utils.formatDateJP(req.unloadDate)} ${Utils.formatTime(req.unloadTime) || ''} - ${req.unloadPlace1}
          </div>
        </div>
      `).join('');
    },
    
    setupEventListeners() {
      console.log('[DispatchPlan.setupEventListeners]'); // ★ DEBUG LOG
      // 当日タブ
      const reloadTodayBtn = document.getElementById('reloadTodayPlanBtn');
      if (reloadTodayBtn) {
        reloadTodayBtn.addEventListener('click', () => this.loadAssignedRequestsByDate(0));
      }

      // ★ NEW: 日付選択ボタン
      const showTodayBtn = document.getElementById('showTodayBtn');
      const showYesterdayBtn = document.getElementById('showYesterdayBtn');
      const showDayBeforeYesterdayBtn = document.getElementById('showDayBeforeYesterdayBtn');

      if (showTodayBtn) {
        showTodayBtn.addEventListener('click', () => this.loadAssignedRequestsByDate(0));
      }
      if (showYesterdayBtn) {
        showYesterdayBtn.addEventListener('click', () => this.loadAssignedRequestsByDate(-1));
      }
      if (showDayBeforeYesterdayBtn) {
        showDayBeforeYesterdayBtn.addEventListener('click', () => this.loadAssignedRequestsByDate(-2));
      }

      const todayContainer = document.getElementById('todayAssignedRequests');
      if (todayContainer) {
        todayContainer.addEventListener('click', (e) => {
          const unassignBtn = e.target.closest('.unassign-btn');
          if (unassignBtn) {
            const requestId = unassignBtn.dataset.requestId;
            this.handleUnassignClick(requestId);
          }
        });
      }

      // 未配車タブ
      const applyBtn = document.getElementById('planApplyFilterBtn');
      if (applyBtn) {
        applyBtn.addEventListener('click', () => this.applyPlanFilters());
      }
      const resetBtn = document.getElementById('planResetFilterBtn');
      if (resetBtn) {
        resetBtn.addEventListener('click', () => this.resetPlanFilters());
      }
      const cancelBtn = document.getElementById('cancelVehicleSelectBtn');
      if (cancelBtn) {
        cancelBtn.addEventListener('click', () => this.cancelVehicleSelection());
      }
      const unassignedContainer = document.getElementById('unassignedRequests');
      if (unassignedContainer) {
        unassignedContainer.addEventListener('click', (e) => {
          const card = e.target.closest('.request-card');
          if (card) {
            const requestId = card.dataset.requestId;
            this.selectRequestForDispatch(requestId);
          }
        });
      }
    },
    
    async handleUnassignClick(requestId) {
      console.log(`[DispatchPlan.handleUnassignClick] ID: ${requestId}`); // ★ DEBUG LOG
      if (!UI.confirm(`依頼ID: ${requestId} の配車を解除しますか？`)) {
        return;
      }
      
      try {
        UI.showLoading('配車を解除しています...');
        const result = await API.unassignVehicle(requestId);
        UI.hideLoading();
        
        if (result.success) {
          UI.showSuccess('配車を解除しました');
          // 両方のタブをリフレッシュ
          await this.loadTodayAssignedRequests();
          await this.loadUnassignedRequests();
        } else {
          UI.showError('配車解除に失敗しました: ' + result.message);
        }
      } catch (error) {
        console.error('Unassign error:', error);
        UI.hideLoading();
        UI.showError('配車解除に失敗しました: ' + error.message);
      }
    },
    
    applyPlanFilters() {
      if (!AppState.requests) return;
      const date = document.getElementById('planFilterDate').value;
      const shipperId = document.getElementById('planFilterShipper').value;
      const type = document.getElementById('planFilterType').value;
      // ★ 修正: 問題点2の修正 (案A: プルダウンから値を取得)
      const status = document.getElementById('planFilterStatus').value;
      
      let filtered = AppState.requests;
      
      // ★ 修正: 問題点2の修正 (案A: フィルターロジック変更)
      if (status === 'unassigned') {
        filtered = filtered.filter(req => !req.vehicleNumber);
      }
      // 'all' の場合は何もしない
      
      if (date) {
        filtered = filtered.filter(req => req.loadDate === date);
      }
      if (shipperId) {
        filtered = filtered.filter(req => req.shipperId === shipperId);
      }
      if (type) {
        filtered = filtered.filter(req => req.requestType === type);
      }
      
      this.renderRequests(filtered);
    },
    
    resetPlanFilters() {
      document.getElementById('planFilterDate').value = '';
      document.getElementById('planFilterShipper').value = '';
      document.getElementById('planFilterType').value = '';
      // ★ 修正: 問題点2の修正 (案A: プルダウンをリセット)
      document.getElementById('planFilterStatus').value = 'unassigned';
      M.FormSelect.init(document.querySelectorAll('select'));
      
      // ★ 修正: フィルターロジックを applyPlanFilters に任せる
      this.applyPlanFilters();
    },
    
    async selectRequestForDispatch(requestId) {
      console.log(`[DispatchPlan.selectRequest] ID: ${requestId}`); // ★ DEBUG LOG
      try {
        const request = AppState.requests.find(r => r.requestId === requestId);
        if (!request) return;
        AppState.selectedRequest = request;
        
        document.querySelectorAll('.request-card').forEach(card => {
          card.classList.toggle('selected', card.dataset.requestId === requestId);
        });
        
        this.showVehicleSelector(request);
        
        UI.showLoading('利用可能な車両を検索中...');
        const vehicles = await API.getAvailableVehicles(request);
        UI.hideLoading();
        
        this.renderAvailableVehicles(vehicles, request);
      } catch (error) {
        console.error('Select request error:', error);
        UI.hideLoading();
        UI.showError('車両の検索に失敗しました: ' + error.message);
      }
    },
    
    showVehicleSelector(request) {
      Utils.toggleElement('vehicleSelectorCard', true);
      Utils.toggleElement('helpCard', false);
      const infoDiv = document.getElementById('selectedRequestInfo');
      if (infoDiv) {
        infoDiv.innerHTML = `
          <div style="background-color: #E3F2FD; padding: 15px; border-radius: 5px;">
            <h6 style="margin: 0 0 10px 0; color: #1976D2;">
              <strong>${request.requestId}</strong>
            </h6>
            <p style="margin: 5px 0;"><strong>荷主:</strong> ${request.shipper}</p>
            <p style="margin: 5px 0;"><strong>品名:</strong> ${request.productName}</p>
            <p style="margin: 5px 0;"><strong>積込:</strong> ${Utils.formatDateJP(request.loadDate)} ${Utils.formatTime(request.loadTime) || ''}</p>
            <p style="margin: 5px 0;"><strong>荷卸:</strong> ${Utils.formatDateJP(request.unloadDate)} ${Utils.formatTime(request.unloadTime) || ''}</p>
            <p style="margin: 5px 0;"><strong>依頼車種:</strong> <span class="chip chip-info">${request.requestType}</span></p>
          </div>
        `;
      }
    },
    
    renderAvailableVehicles(vehicles, request) {
      console.log(`[DispatchPlan.renderAvailableVehicles] Rendering ${vehicles.length} vehicles`); // ★ DEBUG LOG
      const container = document.getElementById('availableVehicles');
      if (!container) return;
      if (vehicles.length === 0) {
        container.innerHTML = '<p class="text-center text-secondary">この依頼に割り当て可能な車両がありません</p>';
        return;
      }
      container.innerHTML = vehicles.map(vehicle => `
        <div class="vehicle-item" data-vehicle-number="${vehicle.number}">
          <div style="display: flex; justify-content: space-between; align-items: center;">
            <div>
              <strong>${vehicle.number}</strong>
              <span class="chip chip-info" style="margin-left: 10px;">${vehicle.vehicleType}</span>
            </div>
            <button class="btn-small waves-effect waves-light blue darken-1 assign-vehicle-btn" 
                    data-vehicle-number="${vehicle.number}"
                    data-request-id="${request.requestId}">
              <i class="material-icons left">check</i>
              割り当て
            </button>
          </div>
          <div style="margin-top: 5px; font-size: 0.875rem; color: #757575;">
            <div>車番: ${vehicle.radioNumber || '-'}</div>
            <div>運転手: ${vehicle.driverName || '-'}</div>
            <div>積載量: ${vehicle.capacity || '-'}</div>
          </div>
        </div>
      `).join('');
      
      container.querySelectorAll('.assign-vehicle-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const vehicleNumber = btn.dataset.vehicleNumber;
          const requestId = btn.dataset.requestId;
          this.assignVehicleToRequest(requestId, vehicleNumber);
        });
      });
    },
    
    async assignVehicleToRequest(requestId, vehicleNumber) {
      console.log(`[DispatchPlan.assignVehicle] Assigning ${vehicleNumber} to ${requestId}`); // ★ DEBUG LOG
      if (!UI.confirm('この車両を割り当てますか?')) {
        return;
      }
      try {
        UI.showLoading('車両を割り当て中...');
        const result = await API.assignVehicle(requestId, vehicleNumber);
        UI.hideLoading();
        if (result.success) {
          UI.showSuccess('車両を割り当てました');
          this.cancelVehicleSelection();
          // 両方のタブをリフレッシュ
          await this.loadTodayAssignedRequests();
          await this.loadUnassignedRequests();
        } else {
          UI.showError('車両の割り当てに失敗しました: ' + result.message);
        }
      } catch (error) {
        console.error('Assign vehicle error:', error);
        UI.hideLoading();
        UI.showError('車両の割り当てに失敗しました: ' + error.message);
      }
    },
    
    cancelVehicleSelection() {
      console.log('[DispatchPlan.cancelVehicleSelection]'); // ★ DEBUG LOG
      Utils.toggleElement('vehicleSelectorCard', false);
      Utils.toggleElement('helpCard', true);
      document.querySelectorAll('.request-card').forEach(card => card.classList.remove('selected'));
      AppState.selectedRequest = null;
    }
  };
  
  // ===========================================================================
  // グローバルに公開
  // ===========================================================================
  
  window.App = App;
  window.AppState = AppState;
  window.API = API;
  window.UI = UI;
  window.Utils = Utils;
  window.RequestForm = RequestForm;
  window.RequestList = RequestList;
  window.DispatchPlan = DispatchPlan;
  
  // ===========================================================================
  // DOMContentLoaded イベント
  // ===========================================================================
  
  document.addEventListener('DOMContentLoaded', () => {
    console.log('DOMContentLoaded: App initializing...');
    console.log('[DEBUG] Current page from APP_CONFIG:', window.APP_CONFIG.currentPage);

    document.querySelectorAll('.loading-overlay').forEach(el => {
      console.warn('[EMERGENCY CLEANUP] Removing orphaned loading overlay');
      el.remove();
    });

    const initialPage = window.APP_CONFIG.currentPage;
    console.log('[SPA] Setting initial active page:', initialPage);
    document.querySelectorAll(`nav a[data-page="${initialPage}"]`).forEach(link => {
      const li = link.closest('li');
      if (li) {
        li.classList.add('active');
      }
    });

    App.init();
  });
  
})();
</script>